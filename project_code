module float_mac(
input [15:0] num1, // multiplicand for multiplication stage 
input [15:0] num2, // multiplier for multiplication stage 
input [15:0] num3, // number to add (accumulate)
output [15:0] result, // final MAC result 
output overflow, // overflow flag 
output zero, // zero flag
output NaN, // Not-a-Number flag 
output precisionLost // precision lost flag
);
// Internal signals from the multiplier stage 
wire [15:0] mult_result;
wire mult_overflow; 
wire mult_zero;
wire mult_NaN;
wire mult_precisionLost;
// Instantiate the floating point multiplier. 
float_multi u_mult (
.num1(num1),
.num2(num2),
.result(mult_result),
.overflow(mult_overflow),
.zero(mult_zero),
.NaN(mult_NaN),
.precisionLost(mult_precisionLost)
);
// Internal signals from the adder stage 
wire [15:0] add_result;
wire add_overflow;
wire add_zero;
wire add_NaN;
wire add_precisionLost;
// Instantiate the floating point adder.
// It adds the product (mult_result) to num3. 
float_adder u_add (
.num1(mult_result),
.num2(num3),
.result(add_result),
.overflow(add_overflow),
.zero(add_zero),
.NaN(add_NaN),
.precisionLost(add_precisionLost)
);
// The final MAC result is the output of the adder. 
assign result = add_result;
// Combine error flags from both stages.
assign overflow = mult_overflow | add_overflow; 
assign zero = mult_zero | add_zero;
assign NaN = mult_NaN | add_NaN;
assign precisionLost = mult_precisionLost | add_precisionLost; 
endmodule
# MULTIPLICATION:
//float multi multiplier floating point numbers.
module float_multi(num1, num2, result, overflow, zero, NaN, precisionLost);
//Operands
input [15:0] num1, num2; 
output [15:0] result;
//Flags
output overflow;//overflow flag 
output zero; //zero flag
output NaN; //Not a Number flag 
output precisionLost;
//Decode numbers
wire sign1, sign2, signR; //hold signs
wire [4:0] ex1, ex2, exR; //hold exponents
wire [4:0] ex1_pre, ex2_pre, exR_calc; //hold exponents 
reg [4:0] exSubCor;
wire [4:0] exSum_fault; 
wire ex_cannot_correct;
wire [9:0] fra1, fra2, fraR; //hold fractions 
reg [9:0] fraSub, fraSub_corrected;
wire [20:0] float1;
wire [10:0] float2; 
wire exSum_sign; 
wire [6:0] exSum;
wire [5:0] exSum_prebais, exSum_abs; //exponent sum 
wire [11:0] float_res, float_res_preround; //result
wire [9:0] float_res_fra;
wire [9:0] dump_res; //Lost precision 
reg [21:0] res_full;
wire [21:0] res_full_preshift;
reg [20:0] mid[10:0];
wire inf_num; //at least on of the operands is inf. 
wire subNormal;
wire zero_num_in, zero_calculated;
//Partial flags
assign zero_num_in = ~(|num1[14:0] & |num2[14:0]);
assign zero_calculated = (subNormal & (fraSub == 10'd0)) | (exSum_sign & 
(~|res_full[20:11]));
assign ex_cannot_correct = {1'b0,exSubCor} > exSum_abs; //?: or >=
//Flags
assign zero = zero_num_in | zero_calculated;
assign NaN = (&num1[14:10] & |num1[9:0]) | (&num2[14:10] & |num2[9:0]); 
assign inf_num = (&num1[14:10] & ~|num1[9:0]) | (&num2[14:10] &
~|num2[9:0]); //check for infinate number
assign overflow = inf_num | (~exSum[6] & exSum[5]); 
assign subNormal = ~|float_res[11:10];
assign precisionLost = |dump_res | (exSum_prebais < 6'd15);
//decode-encode numbers
assign {sign1, ex1_pre, fra1} = num1; 
assign {sign2, ex2_pre, fra2} = num2; 
assign ex1 = ex1_pre + {4'd0, ~|ex1_pre}; 
assign ex2 = ex2_pre + {4'd0, ~|ex2_pre}; 
assign result = {signR, exR, fraR};
//exponentials are added
assign exSum = exSum_prebais - 7'd15;
assign exSum_prebais = {1'b0,ex1} + {1'b0,ex2};
assign exSum_abs = (exSum_sign) ? (~exSum[5:0] + 6'd1) : exSum[5:0]; 
assign exSum_sign = exSum[6];
//Get floating numbers
assign float1 = {|ex1_pre, fra1, 10'd0}; 
assign float2 = {|ex2_pre, fra2};
//Calculate result
assign signR = (sign1 ^ sign2);
assign exR_calc = exSum[4:0] + {4'd0, float_res[11]} + (~exSubCor &
{5{subNormal}}) + {4'd0, subNormal};
assign exR = (exR_calc | {5{overflow}}) & {5{~(zero | exSum_sign | 
ex_cannot_correct)}};
assign fraR = ((exSum_sign) ? res_full[20:11] :((subNormal) ? fraSub_corrected : 
float_res_fra)) & {10{~(zero | overflow)}} ;
assign float_res_fra = (float_res[11]) ? float_res[10:1] : float_res[9:0]; 
assign float_res = float_res_preround + {10'd0,dump_res[9]}; //? possibly 
generates wrong result due to overflow
assign {float_res_preround, dump_res} = res_full_preshift;
assign res_full_preshift = mid[0] + mid[1] + mid[2] + mid[3] + mid[4] + mid[5] + 
mid[6] + mid[7] + mid[8] + mid[9] + mid[10];
assign exSum_fault = exSubCor - exSum_abs[4:0]; 
always@*
begin 
if(exSum_sign) 
case(exSum_abs)
6'h0: res_full = res_full_preshift;
6'h1: res_full = (res_full_preshift >> 1); 
6'h2: res_full = (res_full_preshift >> 2);
6'h3: res_full = (res_full_preshift >> 3);
6'h4: res_full = (res_full_preshift >> 4);
6'h5: res_full = (res_full_preshift >> 5);
6'h6: res_full = (res_full_preshift >> 6);
6'h7: res_full = (res_full_preshift >> 7);
6'h8: res_full = (res_full_preshift >> 8);
6'h9: res_full = (res_full_preshift >> 9);
6'ha: res_full = (res_full_preshift >> 10); 
6'hb: res_full = (res_full_preshift >> 11); 
6'hc: res_full = (res_full_preshift >> 12); 
6'hd: res_full = (res_full_preshift >> 13); 
6'he: res_full = (res_full_preshift >> 14); 
6'hf: res_full = (res_full_preshift >> 15); 
default: res_full = (res_full_preshift >> 16); 
endcase
else
res_full = res_full_preshift; 
end
always@* 
begin
if(ex_cannot_correct) 
case(exSum_fault)
5'h0: fraSub_corrected = fraSub;
5'h1: fraSub_corrected = (fraSub >> 1); 
5'h2: fraSub_corrected = (fraSub >> 2); 
5'h3: fraSub_corrected = (fraSub >> 3); 
5'h4: fraSub_corrected = (fraSub >> 4); 
5'h5: fraSub_corrected = (fraSub >> 5); 
5'h6: fraSub_corrected = (fraSub >> 6); 
5'h7: fraSub_corrected = (fraSub >> 7);
5'h8: fraSub_corrected = (fraSub >> 8); 
5'h9: fraSub_corrected = (fraSub >> 9); 
default: fraSub_corrected = 10'h0; 
endcase
else
fraSub_corrected = fraSub; 
end
always@* //create mids from fractions 
begin
mid[0] = (float1 >> 10) & {21{float2[0]}};
mid[1] = (float1 >> 9) & {21{float2[1]}};
mid[2] = (float1 >> 8) & {21{float2[2]}};
mid[3] = (float1 >> 7) & {21{float2[3]}};
mid[4] = (float1 >> 6) & {21{float2[4]}};
mid[5] = (float1 >> 5) & {21{float2[5]}};
mid[6] = (float1 >> 4) & {21{float2[6]}};
mid[7] = (float1 >> 3) & {21{float2[7]}};
mid[8] = (float1 >> 2) & {21{float2[8]}};
mid[9] = (float1 >> 1) & {21{float2[9]}}; 
mid[10] = float1 & {21{float2[10]}}; 
end
//Corrections forsubnormal normal op 
always@*
begin 
casex(res_full)
22'b001xxxxxxxxxxxxxxxxxxx: 
begin
fraSub = res_full[18:9]; 
end
22'b0001xxxxxxxxxxxxxxxxxx: 
begin
fraSub = res_full[17:8]; 
end
22'b00001xxxxxxxxxxxxxxxxx: 
begin
fraSub = res_full[16:7]; 
end
22'b000001xxxxxxxxxxxxxxxx: 
begin
fraSub = res_full[15:6]; 
end
22'b0000001xxxxxxxxxxxxxxx: 
begin
fraSub = res_full[14:5]; 
end
22'b00000001xxxxxxxxxxxxxx: 
begin
fraSub = res_full[13:4]; 
end
22'b000000001xxxxxxxxxxxxx: 
begin
fraSub = res_full[12:3]; 
end
22'b0000000001xxxxxxxxxxxx: 
begin
fraSub = res_full[11:2]; 
end
22'b00000000001xxxxxxxxxxx: 
begin
fraSub = res_full[10:1]; 
end
22'b000000000001xxxxxxxxxx: 
begin
fraSub = res_full[9:0]; 
end
22'b0000000000001xxxxxxxxx: 
begin
fraSub = {res_full[8:0], 1'd0}; 
end 
22'b00000000000001xxxxxxxx: 
begin
fraSub = {res_full[7:0], 2'd0}; 
end 
22'b000000000000001xxxxxxx:
begin
fraSub = {res_full[6:0], 3'd0}; 
end 
22'b0000000000000001xxxxxx:
begin
fraSub = {res_full[5:0], 4'd0}; 
end 
22'b00000000000000001xxxxx:
begin
fraSub = {res_full[4:0], 5'd0}; 
end 
22'b000000000000000001xxxx:
begin
fraSub = {res_full[3:0], 6'd0}; 
end 
22'b0000000000000000001xxx:
begin
fraSub = {res_full[2:0], 7'd0}; 
end 
22'b00000000000000000001xx:
begin
fraSub = {res_full[1:0], 8'd0}; 
end 
22'b000000000000000000001x:
begin
fraSub = {res_full[0], 9'd0}; 
end
default: 
begin
fraSub = 10'd0; 
end
endcase 
end 
always@* 
begin
casex(res_full) 
22'b001xxxxxxxxxxxxxxxxxxx: 
begin
exSubCor = 5'd1; 
end
22'b0001xxxxxxxxxxxxxxxxxx: 
begin
exSubCor = 5'd2; 
end
22'b00001xxxxxxxxxxxxxxxxx: 
begin
exSubCor = 5'd3; 
end
22'b000001xxxxxxxxxxxxxxxx: 
begin
exSubCor = 5'd4; 
end
22'b0000001xxxxxxxxxxxxxxx: 
begin
exSubCor = 5'd5; 
end
22'b00000001xxxxxxxxxxxxxx: 
begin
exSubCor = 5'd6; 
end
22'b000000001xxxxxxxxxxxxx: 
begin
exSubCor = 5'd7; 
end
22'b0000000001xxxxxxxxxxxx: 
begin
exSubCor = 5'd8; 
end
22'b00000000001xxxxxxxxxxx: 
begin
exSubCor = 5'd9;
end
22'b000000000001xxxxxxxxxx: 
begin
exSubCor = 5'd10; 
end
22'b0000000000001xxxxxxxxx: 
begin
exSubCor = 5'd11; 
end
22'b00000000000001xxxxxxxx: 
begin
exSubCor = 5'd12; 
end
22'b000000000000001xxxxxxx:
begin
exSubCor = 5'd13; 
end
22'b0000000000000001xxxxxx:
begin
exSubCor = 5'd14; 
end
22'b00000000000000001xxxxx:
begin
exSubCor = 5'd15; 
end
22'b000000000000000001xxxx:
begin
exSubCor = 5'd16; 
end
22'b0000000000000000001xxx:
begin
exSubCor = 5'd17; 
end
22'b00000000000000000001xx:
begin
exSubCor = 5'd18; 
end
22'b000000000000000000001x:
Begin
exSubCor = 5'd19; 
end
default:
begin
exSubCor = 5'd0; 
end
endcase 
end
endmodule
ADDITION:
//float adder adds floating point numbers.
module float_adder(num1, num2, result, overflow, zero, NaN, precisionLost);
//Ports
input [15:0] num1, num2; 
output [15:0] result;
output overflow; //overflow flag 
output zero; //zero flag
output NaN; //Not a Number flag 
output reg precisionLost;
//Reassing numbers as big and small
reg [15:0] bigNum, smallNum; //to seperate big and small numbers
//Decode big and small number
wire [9:0] big_fra, small_fra; //to hold fraction part 
wire [4:0] big_ex_pre, small_ex_pre;
wire [4:0] big_ex, small_ex; //to hold exponent part 
wire big_sig, small_sig; //to hold signs
wire [10:0] big_float, small_float; //to hold as float number with integer 
reg [10:0] sign_small_float, shifted_small_float; //preparing small float 
wire [4:0] ex_diff; //difrence between exponentials
reg [9:0] sum_shifted; //Shift fraction part of sum 
reg [3:0] shift_am;
wire neg_exp;
//Extensions for higher precision 
reg [9:0] small_extension;
wire [9:0] sum_extension;
wire [10:0] sum; //sum of numbers with integer parts 
wire sum_carry;
wire sameSign;
wire zeroSmall;
wire inf_num; //at least on of the operands is inf. 
wire [4:0] res_exp_same_s, res_exp_diff_s;
//Flags
assign zero = (num1[14:0] == num2[14:0]) & (~num1[15] == num2[15]); 
assign overflow = ((&big_ex[4:1] & ~big_ex[0]) & sum_carry & sameSign) | 
inf_num;
assign NaN = (&num1[14:10] & |num1[9:0]) | (&num2[14:10] & |num2[9:0]); 
assign inf_num = (&num1[14:10] & ~|num1[9:0]) | (&num2[14:10] &
~|num2[9:0]); //check for infinate number
//Get result
assign result[15] = big_sig; //result sign same as big sign
assign res_exp_same_s = big_ex + {4'd0, (~zeroSmall & sum_carry & sameSign)}
- {4'd0,({1'b0,result[9:0]} == sum)};
assign res_exp_diff_s = (neg_exp | (shift_am == 4'd10)) ? 5'd0 : (~shift_am + 
big_ex + 5'd1);
assign result[14:10] = ((sameSign) ? res_exp_same_s : res_exp_diff_s) |
{5{overflow}}; //result exponent
assign result[9:0] = ((zeroSmall) ? big_fra : ((sameSign) ? ((sum_carry) ? 
sum[10:1] : sum[9:0]) : ((neg_exp) ? 10'd0 : sum_shifted))) & {10{~overflow}};
//decode numbers
assign {big_sig, big_ex_pre, big_fra} = bigNum;
assign {small_sig, small_ex_pre, small_fra} = smallNum; 
assign sameSign = (big_sig == small_sig);
assign zeroSmall = ~(|small_ex | |small_fra);
assign big_ex = big_ex_pre + {4'd0, ~|big_ex_pre};
assign small_ex = small_ex_pre + {4'd0, ~|small_ex_pre};
//add integer parts
assign big_float = {|big_ex_pre, big_fra};
assign small_float = {|small_ex_pre, small_fra};
assign ex_diff = big_ex - small_ex; //diffrence between exponents 
assign {sum_carry, sum} = sign_small_float + big_float; //add numbers 
assign sum_extension = small_extension;
//Get shift amount for subtraction 
assign neg_exp = (big_ex < shift_am); 
always@*
begin 
casex(sum)
11'b1xxxxxxxxxx: shift_am = 4'd0; 
11'b01xxxxxxxxx: shift_am = 4'd1; 
11'b001xxxxxxxx: shift_am = 4'd2;
11'b0001xxxxxxx: shift_am = 4'd3; 
11'b00001xxxxxx: shift_am = 4'd4; 
11'b000001xxxxx: shift_am = 4'd5; 
11'b0000001xxxx: shift_am = 4'd6; 
11'b00000001xxx: shift_am = 4'd7; 
11'b000000001xx: shift_am = 4'd8; 
11'b0000000001x: shift_am = 4'd9; 
default: shift_am = 4'd10;
endcase 
end
//Shift result forsub. 
always@*
begin
case (shift_am)
4'd0: sum_shifted = sum[9:0];
4'd1: sum_shifted = {sum[8:0],sum_extension[9]}; 
4'd2: sum_shifted = {sum[7:0],sum_extension[9:8]}; 
4'd3: sum_shifted = {sum[6:0],sum_extension[9:7]}; 
4'd4: sum_shifted = {sum[5:0],sum_extension[9:6]}; 
4'd5: sum_shifted = {sum[4:0],sum_extension[9:5]}; 
4'd6: sum_shifted = {sum[3:0],sum_extension[9:4]}; 
4'd7: sum_shifted = {sum[2:0],sum_extension[9:3]}; 
4'd8: sum_shifted = {sum[1:0],sum_extension[9:2]}; 
4'd9: sum_shifted = {sum[0], sum_extension[9:1]}; 
default: sum_shifted = sum_extension;
endcase
case (shift_am)
4'd0: precisionLost = |sum_extension; 
4'd1: precisionLost = |sum_extension[8:0]; 
4'd2: precisionLost = |sum_extension[7:0]; 
4'd3: precisionLost = |sum_extension[6:0]; 
4'd4: precisionLost = |sum_extension[5:0]; 
4'd5: precisionLost = |sum_extension[4:0]; 
4'd6: precisionLost = |sum_extension[3:0]; 
4'd7: precisionLost = |sum_extension[2:0]; 
4'd8: precisionLost = |sum_extension[1:0]; 
4'd9: precisionLost = |sum_extension[0]; 
default: precisionLost = 1'b0;
endcase 
end
//take small number to exponent of big number 
always@*
begin
case (ex_diff)
5'h0: {shifted_small_float,small_extension} = {small_float,10'd0}; 
5'h1: {shifted_small_float,small_extension} = {small_float,9'd0}; 
5'h2: {shifted_small_float,small_extension} = {small_float,8'd0}; 
5'h3: {shifted_small_float,small_extension} = {small_float,7'd0}; 
5'h4: {shifted_small_float,small_extension} = {small_float,6'd0}; 
5'h5: {shifted_small_float,small_extension} = {small_float,5'd0}; 
5'h6: {shifted_small_float,small_extension} = {small_float,4'd0};
5'h7: {shifted_small_float,small_extension} = {small_float,3'd0}; 
5'h8: {shifted_small_float,small_extension} = {small_float,2'd0}; 
5'h9: {shifted_small_float,small_extension} = {small_float,1'd0}; 
5'ha: {shifted_small_float,small_extension} = small_float;
5'hb: {shifted_small_float,small_extension} = small_float[10:1]; 
5'hc: {shifted_small_float,small_extension} = small_float[10:2]; 
5'hd: {shifted_small_float,small_extension} = small_float[10:3]; 
5'he: {shifted_small_float,small_extension} = small_float[10:4]; 
5'hf: {shifted_small_float,small_extension} = small_float[10:5]; 
5'h10: {shifted_small_float,small_extension} = small_float[10:5]; 
5'h11: {shifted_small_float,small_extension} = small_float[10:6]; 
5'h12: {shifted_small_float,small_extension} = small_float[10:7]; 
5'h13: {shifted_small_float,small_extension} = small_float[10:8]; 
5'h14: {shifted_small_float,small_extension} = small_float[10:9]; 
5'h15: {shifted_small_float,small_extension} = small_float[10]; 
5'h16: {shifted_small_float,small_extension} = 0;
endcase 
end
always@* //if signs are diffrent take 2s compliment of small number 
begin
if(sameSign) 
begin
sign_small_float = shifted_small_float; 
end
else
begin
sign_small_float = ~shifted_small_float + 11'b1; 
end
end
always@* //determine big number 
begin
if(num2[14:10] > num1[14:10])
begin
bigNum = num2; 
smallNum = num1; 
end
else if(num2[14:10] == num1[14:10]) 
begin
if(num2[9:0] > num1[9:0]) 
begin
bigNum = num2; 
smallNum = num1; 
end
else
begin
bigNum = num1; 
smallNum = num2; 
end
end 
else
begin
bigNum = num1; 
smallNum = num2; 
end
end 
endmodule
PRECISION CONTROL:
module Reduction_and8bit(input [7:0] in,output out); 
wire w1,w2,w3,w4,w5,w6;
and(w1,in[1],in[0]);
and(w2,in[2],w1);
and(w3,in[3],w2);
and(w4,in[4],w3);
and(w5,in[5],w4);
and(w6,in[6],w5);
and(out,in[7],w6); 
endmodule
module Reduction_or8bit(input [7:0] in,output out); 
wire w1,w2,w3,w4,w5,w6;
or(w1,in[1],in[0]);
or(w2,in[2],w1);
or(w3,in[3],w2);
or(w4,in[4],w3);
or(w5,in[5],w4);
or(w6,in[6],w5);
or(out,in[7],w6); 
endmodule
module Reduction_or24bit(input [23:0] in,output out); 
Reduction_or8bit RO01(.in(in[7:0]),.out(o1)); 
Reduction_or8bit RO02(.in(in[15:8]),.out(o2)); 
Reduction_or8bit RO03(.in(in[23:16]),.out(o3)); 
or(out,o1,o2,o3);
endmodule
module Reduction_nor31bit(input [30:0] in,output out); 
Reduction_or24bit RO01(.in(in[23:0]),.out(o1)); 
Reduction_or8bit RO02(.in({1'b0,in[30:24]}),.out(o2)); 
nor(out,o1,o2);
endmodule
module Complement8bit(input [7:0] in,output [7:0] out); 
not(out[0],in[0]);
not(out[1],in[1]);
not(out[2],in[2]);
not(out[3],in[3]);
not(out[4],in[4]);
not(out[5],in[5]);
not(out[6],in[6]);
not(out[7],in[7]); 
endmodule
module Complement24bit(input [23:0] in,output [23:0] out); 
Complement8bit C01(.in(in[7:0]),.out(out[7:0]));
Complement8bit C02(.in(in[15:8]),.out(out[15:8]));
Complement8bit C03(.in(in[23:16]),.out(out[23:16])); 
endmodule
module Adder4bit(input [3:0] a,input [3:0] b,input cin,output [3:0]sum,output cout); 
wire g0,g1,g2,g3,p0,p1,p2,p3,c2,c1,c0;
assign g0 = a[0]&b[0]; 
assign g1 = a[1]&b[1]; 
assign g2 = a[2]&b[2];
assign g3 = a[3]&b[3]; 
assign p0 = a[0]^b[0]; 
assign p1 = a[1]^b[1]; 
assign p2 = a[2]^b[2]; 
assign p3 = a[3]^b[3]; 
assign c0 = g0 |( p0 & cin);
assign c1 = g1 | (p1&g0)| (p1&p0&cin);
assign c2 = g2 | (p2&g1) | (p2&p1&g0) | (p2&p1&p0&cin); 
assign cout = g3 | (p3&g2) | (p3&p2&g1) | (p3&p2&p1&g0) | 
(p3&p2&p1&p0&cin);
xor(sum[0],p0,cin);
xor(sum[1],p1,c0);
xor(sum[2],p2,c1);
xor(sum[3],p3,c2); 
endmodule
module Adder8bit(input [7:0] a,input [7:0] b,input cin,output [7:0]sum,output cout); 
Adder4bit ADD01(.a(a[3:0]),.b(b[3:0]),.cin(cin),.sum(sum[3:0]),.cout(ctemp));
Adder4bit ADD02(.a(a[7:4]),.b(b[7:4]),.cin(ctemp),.sum(sum[7:4]),.cout(cout)); 
endmodule
module Adder9bit(input [8:0] a,input [8:0] b,input cin,output [8:0]sum,output cout); 
Adder8bit ADD01(.a(a[7:0]),.b(b[7:0]),.cin(cin),.sum(sum[7:0]),.cout(ctemp)); 
xor(sum[8],a[8],b[8],ctemp);
assign cout = a[8]&b[8] | a[8]&ctemp | ctemp&b[8]; 
endmodule
module Adder24bit(input [23:0] a,input [23:0] b,input cin,output [23:0]sum,output 
cout);
Adder8bit ADD01(.a(a[7:0]),.b(b[7:0]),.cin(cin),.sum(sum[7:0]),.cout(ctemp1)); 
Adder8bit 
ADD02(.a(a[15:8]),.b(b[15:8]),.cin(ctemp1),.sum(sum[15:8]),.cout(ctemp2)); 
Adder8bit 
ADD03(.a(a[23:16]),.b(b[23:16]),.cin(ctemp2),.sum(sum[23:16]),.cout(cout)); 
endmodule
module Complement8bit_2s(input [7:0] in,output [7:0] out);
wire [7:0] outtemp;
Complement8bit C01(.in(in),.out(outtemp));
Adder8bit ADD01(.a(outtemp),.b(8'b0000_0001),.cin(1'b0),.sum(out),.cout()); 
endmodule
module Complement24bit_2s(input [23:0] in,output [23:0] out);
wire [23:0] outtemp;
Complement24bit C01(.in(in),.out(outtemp));

Adder24bit 
ADD01(.a(outtemp),.b(24'b0000_0000_0000_0000_0000_0001),.cin(1'b0),.sum(ou 
t),.cout());
endmodule
module Mux_1Bit(input in0,input in1 ,input sl,output out); 
wire w1,w2,invSL;
not(invSL,sl); 
and(w1,in0,invSL); 
and(w2,in1,sl);
or(out,w1,w2); 
endmodule
module Mux_8Bit(input [7:0] in0,input [7:0] in1 ,input sl,output [7:0] out); 
Mux_1Bit M01(.in0(in0[0]),.in1(in1[0]) ,.sl(sl),.out(out[0]));
Mux_1Bit M02(.in0(in0[1]),.in1(in1[1]) ,.sl(sl),.out(out[1]));
Mux_1Bit M03(.in0(in0[2]),.in1(in1[2]) ,.sl(sl),.out(out[2]));
Mux_1Bit M04(.in0(in0[3]),.in1(in1[3]) ,.sl(sl),.out(out[3]));
Mux_1Bit M05(.in0(in0[4]),.in1(in1[4]) ,.sl(sl),.out(out[4]));
Mux_1Bit M06(.in0(in0[5]),.in1(in1[5]) ,.sl(sl),.out(out[5]));
Mux_1Bit M07(.in0(in0[6]),.in1(in1[6]) ,.sl(sl),.out(out[6]));
Mux_1Bit M08(.in0(in0[7]),.in1(in1[7]) ,.sl(sl),.out(out[7])); 
endmodule
module Mux_24Bit(input [23:0] in0,input [23:0] in1 ,input sl,output [23:0] out); 
Mux_8Bit M01(.in0(in0[7:0]),.in1(in1[7:0]) ,.sl(sl),.out(out[7:0]));
Mux_8Bit M02(.in0(in0[15:8]),.in1(in1[15:8]) ,.sl(sl),.out(out[15:8]));
Mux_8Bit M03(.in0(in0[23:16]),.in1(in1[23:16]) ,.sl(sl),.out(out[23:16])); 
endmodule
module Mux_32Bit(input [31:0] in0,input [31:0] in1 ,input sl,output [31:0] out); 
Mux_24Bit M01(.in0(in0[23:0]),.in1(in1[23:0]),.sl(sl),.out(out[23:0]));
Mux_8Bit M02(.in0(in0[31:24]),.in1(in1[31:24]),.sl(sl),.out(out[31:24])); 
endmodule
module Multiplier24bit(input [23:0] a,input [23:0] b,output [47:0]mul); 
assign mul = a*b;
endmodule
module Divider24bit(input [47:0] a,input [23:0] b,output [24:0]div); 
wire [47:0] div_temp;
assign div_temp = a/b; 
assign div = div_temp[24:0]; 
endmodule

NORMALIZATION AND SHIFTING:
module normalizeMandfindShift( 
input[23:0] M_result,
input M_carry, 
input real_oper,
output reg [22:0] normalized_M, 
output reg [4:0] shift
);
reg [23:0] M_temp; 
always @(*)
begin
if(M_carry & !real_oper) 
begin
normalized_M = M_result[23:1] + {22'b0,M_result[0]}; 
shift = 5'd0;
end 
else 
begin
casex(M_result) 
24'b1xxx_xxxx_xxxx_xxxx_xxxx_xxxx: 
begin
normalized_M = M_result[22:0]; 
shift = 5'd0;
end 
24'b01xx_xxxx_xxxx_xxxx_xxxx_xxxx: 
begin
M_temp = M_result << 1; 
normalized_M = M_temp[22:0]; 
shift = 5'd1;
end 
24'b001x_xxxx_xxxx_xxxx_xxxx_xxxx: 
begin
M_temp = M_result << 2; 
normalized_M = M_temp[22:0]; 
shift = 5'd2;
end 
24'b0001_xxxx_xxxx_xxxx_xxxx_xxxx: 
begin
M_temp = M_result << 3; 
normalized_M = M_temp[22:0];
shift = 5'd3; 
end
24'b0000_1xxx_xxxx_xxxx_xxxx_xxxx: 
begin
M_temp = M_result << 4; 
normalized_M = M_temp[22:0]; 
shift = 5'd4;
end 
24'b0000_01xx_xxxx_xxxx_xxxx_xxxx: 
begin
M_temp = M_result << 5; 
normalized_M = M_temp[22:0]; 
shift = 5'd5;
end 
24'b0000_001x_xxxx_xxxx_xxxx_xxxx: 
begin
M_temp = M_result << 6; 
normalized_M = M_temp[22:0]; 
shift = 5'd6;
end 
24'b0000_0001_xxxx_xxxx_xxxx_xxxx: 
begin
M_temp = M_result << 7; 
normalized_M = M_temp[22:0]; 
shift = 5'd7;
end 
24'b0000_0000_1xxx_xxxx_xxxx_xxxx: 
begin
M_temp = M_result << 8; 
normalized_M = M_temp[22:0]; 
shift = 5'd8;
end 
24'b0000_0000_01xx_xxxx_xxxx_xxxx: 
begin
M_temp = M_result << 9; 
normalized_M = M_temp[22:0]; 
shift = 5'd9;
end 
24'b0000_0000_001x_xxxx_xxxx_xxxx: 
Begin
M_temp = M_result << 10; 
normalized_M = M_temp[22:0]; 
shift = 5'd10;
end 
24'b0000_0000_0001_xxxx_xxxx_xxxx: 
begin
M_temp = M_result << 11; 
normalized_M = M_temp[22:0]; 
shift = 5'd11;
end 
24'b0000_0000_0000_1xxx_xxxx_xxxx: 
begin
M_temp = M_result << 12; 
normalized_M = M_temp[22:0]; 
shift = 5'd12;
end 
24'b0000_0000_0000_01xx_xxxx_xxxx: 
begin
M_temp = M_result << 13; 
normalized_M = M_temp[22:0]; 
shift = 5'd13;
end 
24'b0000_0000_0000_001x_xxxx_xxxx: 
begin
M_temp = M_result << 14; 
normalized_M = M_temp[22:0]; 
shift = 5'd14;
end 
24'b0000_0000_0000_0001_xxxx_xxxx: 
begin
M_temp = M_result << 15; 
normalized_M = M_temp[22:0]; 
shift = 5'd15;
end 
24'b0000_0000_0000_0000_1xxx_xxxx: 
begin
M_temp = M_result << 16; 
normalized_M = M_temp[22:0];
shift = 5'd16;
end 
24'b0000_0000_0000_0000_01xx_xxxx:
begin
M_temp = M_result << 17; 
normalized_M = M_temp[22:0]; 
shift = 5'd17;
end 
24'b0000_0000_0000_0000_001x_xxxx: 
begin
M_temp = M_result << 18; 
normalized_M = M_temp[22:0]; 
shift = 5'd18;
end 
24'b0000_0000_0000_0001_0001_xxxx:
begin
M_temp = M_result << 19; 
normalized_M = M_temp[22:0]; 
shift = 5'd19;
end 
24'b0000_0000_0000_0000_0000_1xxx:
begin
M_temp = M_result << 20; 
normalized_M = M_temp[22:0]; 
shift = 5'd20;
end 
24'b0000_0000_0000_0000_0000_01xx:
begin
M_temp = M_result << 21; 
normalized_M = M_temp[22:0]; 
shift = 5'd21;
end 
24'b0000_0000_0000_0000_0000_001x:
begin
M_temp = M_result << 22; 
normalized_M = M_temp[22:0]; 
shift = 5'd22;
end 
24'b0000_0000_0000_0000_0000_0001:
begin
M_temp = M_result << 23; 
normalized_M = M_temp[22:0]; 
shift = 5'd23;
end
default:
begin
normalized_M = 23'b0; 
shift = 5'd0;
end 
endcase 
end
end 
endmodule
SPECIAL CASES
module mul(
input [31:0] n1,
input [31:0] n2,
output [31:0] result, 
output Overflow, 
output Underflow, 
output Exception
);
wire [8:0] sum_E,final_E;
wire [47:0] M_mul_result;
wire [23:0] normalized_M_mul_result;
wire [22:0] final_M; 
wire
final_sign,reduced_and_E1,reduced_and_E2,reduced_or_E1,reduced_or_E2,carry_ 
E;
// Checking whether all the bits of E1, E2 are 1 ==> Then the number will be either 
infinity or NAN ( i.e. an Exception )
Reduction_and8bit RA01(.in(n1[30:23]),.out(reduced_and_E1));
Reduction_and8bit RA02(.in(n2[30:23]),.out(reduced_and_E2));
// If any of E1 or E2 has all btis 1 then we have an Exception( high ) 
or(Exception,reduced_and_E1,reduced_and_E2);
// final sign of the result 
xor(final_sign,n1[31],n2[31]);
// if all the bits of E1 or E2 are 0 ===> Number is denormalized and implied bit of 
the corresponding mantissa is set as 0.
Reduction_or8bit RO01(.in(n1[30:23]),.out(reduced_or_E1)); 
Reduction_or8bit RO02(.in(n1[30:23]),.out(reduced_or_E2));
// Multiplying M1 and M2 ( here we have firstly concatenate the implied bit with the 
corresponding mantissa )
Multiplier24bit 
MUL01(.a({reduced_or_E1,n1[22:0]}),.b({reduced_or_E2,n2[22:0]}),.mul(M_mul
_result));
// MSB of the product is used as select line
// finding the rounding bit ( finally we will or with the LSB of the final product to
include rounding )
// if M_mul_result[47] is 1 ===> product is normalized and we will round off the last 
24 bits else last 23 bits
Reduction_or24bit RO03(.in({1'b0,M_mul_result[22:0]}),.out(mul_round1));
Reduction_or24bit RO04(.in(M_mul_result[23:0]),.out(mul_round2)); 
Mux_1Bit
M01(.in0(mul_round1),.in1(mul_round2),.sl(M_mul_result[47]),.out(final_product
_round));
// normalization
// if MSB of M_mul_result is 1 ===> product is already normalized and next 23 bits 
after MSB is taken
// if MSB of M_mul_result is 0 ===> The next bit is always 1, so starting from next 
to next bit, next 23 bits are taken
// here we do not require to shift any bit 
Mux_24Bit
M02(.in0({1'b0,M_mul_result[45:23]}),.in1({1'b0,M_mul_result[46:24]}),.sl(M_m 
ul_result[47]),.out(normalized_M_mul_result));
Adder24bit 
ADD23(.a({1'b0,normalized_M_mul_result[22:0]}),.b({23'b0,final_product_round
}),.cin(1'b0),.sum({temp,final_M}),.cout());
// Adding E1 and E2 
Adder8bit
ADD01(.a(n1[30:23]),.b(n2[30:23]),.cin(1'b0),.sum(sum_E[7:0]),.cout(sum_E[8]));
// Subtracting 127(BIAS) from sum_E = E1 + E2
// if M_mul_result[47] = 1 ===> product is of the form 11.(something) and we need 
to shift the decimal point to left to make the product normalized and therefore we add 
1 to resultant E
// if M_mul_result[47] = 0 ===> product is of the form 01.(something) and the 
product is already normalized and nothing is added or subtracted to E
Adder9bit 
ADD02(.a(sum_E),.b(9'b110000001),.cin(M_mul_result[47]),.sum(final_E),.cout(c 
arry_E));
// In 2's complement subtraction :
// if carry_E = 0 ===> result is negative and it the case of Underflow
// if carry_E = 1 and MSB of sum(final_E) is 8 (that means sum is atleast 256 ) ===> 
it is the case of Overflow
not(Underflow,carry_E); 
and(Overflow,carry_E,final_E[8]);
assign result = {final_sign,final_E[7:0],final_M}; 
endmodule
module add_sub(
input [31:0] n1,
input [31:0] n2,
output [31:0] result, 
input sub,
output Overflow, 
output Underflow, 
output Exception
);
wire real_oper,real_sign,M_carry; 
wire
isElLessThanE2,reduced_and_E1,reduced_and_E2,reduced_or_E1,reduced_or_E2;
wire [7:0]
temp_exp_diff,One_Added_E,new_E,complemented_temp_exp_diff,exp_diff,E,co 
mplemented_E2,complemented_shift_E;
wire [8:0] final_E;
wire [23:0]
M1,M2,complemented_M2,complemented_M_result,M_result,M_result2,new_M2; 
wire w1,w2,w3,final_sign;
wire [22:0] final_M; 
wire[4:0] shift_E;
// If the bits of E1, E2 are 1 ==> Then the number will be either infinity or NAN ( i.e.
an Exception )
Reduction_and8bit RA01(.in(n1[30:23]),.out(reduced_and_E1)); 
Reduction_and8bit RA02(.in(n2[30:23]),.out(reduced_and_E2));
// If any of E1 or E2 has all btis 1 then we have an Exception( high) 
or(Exception,reduced_and_E1,reduced_and_E2);
// If all the bits of E1 or E2 are 0 ===> Number is denormalized and implied bit of 
the corresponding mantissa is set as 0.
Reduction_or8bit RO01(.in(n1[30:23]),.out(reduced_or_E1)); 
Reduction_or8bit RO02(.in(n1[30:23]),.out(reduced_or_E2));
// Performing E1 - E2
// Before subtraction, complementing E2 bcoz of 2's complement subtraction 
Complement8bit C01(.in(n2[30:23]),.out(complemented_E2));
Adder8bit 
ADD01(.a(n1[30:23]),.b(complemented_E2),.cin(1'b1),.sum(temp_exp_diff),.cout(i 
sE1GreaterThanE2));
// If exp_diff comes out to be -ve ===> Found it's 2's complement
// Original or 2's complement version is selected according to isE1GreaterThanE2
Complement8bit_2s C023(.in(temp_exp_diff),.out(complemented_temp_exp_diff));
Mux_8Bit 
M011(.in0(complemented_temp_exp_diff),.in1(temp_exp_diff),.sl(isE1GreaterTha 
nE2),.out(exp_diff));
// Selecting the larger exponent
Mux_8Bit M03(.in0(n2[30:23]),.in1(n1[30:23]),.sl(isE1GreaterThanE2),.out(E));
// shifting either mantissa of n1 or n2 a/c to isE1GreaterThanE2
assign M1 = isE1GreaterThanE2?
{reduced_or_E1,n1[22:0]}:{reduced_or_E1,n1[22:0]} >> exp_diff;
assign M2 = isE1GreaterThanE2?{reduced_or_E2,n2[22:0]} >> 
exp_diff:{reduced_or_E2,n2[22:0]};
// assuming real_oper and real_sign 
xor(real_oper,sub,n1[31],n2[31]); 
buf(real_sign,n1[31]);
// M2 is added to or subtracted from M1 a/c to real_oper
Complement24bit C02(.in(M2),.out(complemented_M2));
Mux_24Bit M04(.in0(M2),.in1(complemented_M2),.sl(real_oper),.out(new_M2));
Adder24bit 
ADD02(.a(M1),.b(new_M2),.cin(real_oper),.sum(M_result),.cout(M_carry));
// correction in the sign of the final result 
and(w1,~real_sign,real_oper,~M_carry); 
and(w2,~real_oper,real_sign); 
and(w3,M_carry,real_sign); 
or(final_sign,w1,w2,w3);
// 1 is added to E if Addtion is performed b/w mantissae and carry is generated
Adder8bit ADD0212(.a(E),.b(8'd1),.cin(1'b0),.sum(One_Added_E),.cout());
Mux_8Bit 
M031(.in0(E),.in1(One_Added_E),.sl(M_carry&!real_oper),.out(new_E));
// if M_result is negative then 2's complement of M_result is to be calculated
Complement24bit_2s C03(.in(M_result),.out(complemented_M_result));
Mux_24Bit 
M05(.in0(M_result),.in1(complemented_M_result),.sl(real_oper&!M_carry),.out(M
_result2));
// Normalization step ( See Utils.v ) 
normalizeMandfindShift
NM(.M_result(M_result2),.M_carry(M_carry),.real_oper(real_oper),.normalized_M 
(final_M),.shift(shift_E));
Complement8bit C04(.in({3'b000,shift_E}),.out(complemented_shift_E));
// finally shift is subtracted from E ( 2's complement subtraction ) 
Adder8bit
ADD03(.a(new_E),.b(complemented_shift_E),.cin(1'b1),.sum(final_E[7:0]),.cout(fi 
nal_E[8]));
// final ans
assign result = {final_sign,final_E[7:0],final_M};
// if (Carry) final_E[8] = 0 ===> final_E is -ve ( Underflow ) 
not(Underflow,final_E[8]);
// if All bits of of One_Added_E are 1 ( 255 ) and shift_E are 0 ( 0 ), then final_E is 
255 ( Out of bound,i.e, Overflow )
and(Overflow,&One_Added_E,~|shift_E); 
endmodule
module fp_mac(a,b,acc,clk,reset,out); 
input[31:0]a,b,acc;
input clk, reset; 
output [31:0]out;
wire [31:0] fprod, fadd;
reg [31:0] data_a, data_b, fprod1; 
wire
Overflow_mul,Underflow_mul,Exception_mul,Overflow_add,Underflow_add,Exce 
ption_add;
//fpmul mul(clk,reset,a,b,fprod);
mul mul_1(a,b,fprod,Overflow_mul, Underflow_mul,Exception_mul);
//fpadd add(fprod,acc,clk,out);
add_sub add_1(fprod,acc,out,1'b0,Overflow_add,Underflow_add,Exception_add); 
endmodule
DYNAMIC PRECISION CONTROL MAC
module dynamic_precision_fp_mac( 
input clk,
input reset,
input precision_sel, // 0: half precision, 1: single precision

// Half-precision MAC inputs (16-bit IEEE binary16) 
input [15:0] hp_num1,
input [15:0] hp_num2,
input [15:0] hp_num3,
// Single-precision MAC inputs (32-bit IEEE binary32) 
input [31:0] sp_a,
input [31:0] sp_b,
input [31:0] sp_acc,
// Common outputs (always 32-bit) 
output [31:0] result,
output overflow,
output zero,
output NaN,
output precisionLost
);
// Half-precision MAC instance (using the float_mac module) 
wire [15:0] hp_result;
wire hp_overflow, hp_zero, hp_NaN, hp_precisionLost; 
float_mac hp_mac (
.num1(hp_num1),
.num2(hp_num2),
.num3(hp_num3),
.result(hp_result),
.overflow(hp_overflow),
.zero(hp_zero),
.NaN(hp_NaN),
.precisionLost(hp_precisionLost)
);
// Single-precision MAC instance (using the fp_mac module) 
wire [31:0] sp_result;
fp_mac sp_mac (
.a(sp_a),
.b(sp_b),
.acc(sp_acc),
.clk(clk),
.reset(reset),
.out(sp_result)
);
// Dynamic Precision Mux:
assign overflow = (precision_sel == 1'b0) ? hp_overflow : 1'b0; 
assign zero = (precision_sel == 1'b0) ? hp_zero : 1'b0; 
assign NaN = (precision_sel == 1'b0) ? hp_NaN : 1'b0;
assign precisionLost = (precision_sel == 1'b0) ? hp_precisionLost : 1'b0; 
endmodule
